import pygame
import random
import math
import json
import os
import time
import uuid
from pygame import mixer
from datetime import datetime
import builtins

# Pygameの初期化
pygame.init()
mixer.init()

# フルスクリーン設定
FULLSCREEN = False

# ディレクトリ構造の確認と作成
if not os.path.exists("assets"):
    os.makedirs("assets")
    print("assets フォルダを作成しました。必要な画像や音声ファイルを配置してください。")

if not os.path.exists("saves"):
    os.makedirs("saves")

# 定数
BASE_SCREEN_WIDTH = 800
BASE_SCREEN_HEIGHT = 700
BLOCK_SIZE = 30
GRID_WIDTH = 10
GRID_HEIGHT = 20

# グローバル変数
screen_width = BASE_SCREEN_WIDTH
screen_height = BASE_SCREEN_HEIGHT
grid_x = (screen_width - GRID_WIDTH * BLOCK_SIZE) // 2
grid_y = (screen_height - GRID_HEIGHT * BLOCK_SIZE) // 2
scale_factor = 1.0

# 色とテーマ
THEMES = {
    "classic": {
        "background": (0, 0, 0),
        "grid_bg": (20, 20, 20),
        "grid_line": (40, 40, 40),
        "text": (255, 255, 255),
        "ui_bg": (30, 30, 30),
        "ui_border": (100, 100, 100),
        "button": (50, 50, 50),
        "button_hover": (70, 70, 70),
        "button_text": (255, 255, 255),
        "blocks": [
            (0, 255, 255),  # I - シアン
            (255, 255, 0),  # O - イエロー
            (128, 0, 128),  # T - パープル
            (0, 0, 255),  # J - ブルー
            (255, 165, 0),  # L - オレンジ
            (0, 255, 0),  # S - グリーン
            (255, 0, 0),  # Z - レッド
        ],
    },
    "neon": {
        "background": (10, 10, 30),
        "grid_bg": (20, 20, 40),
        "grid_line": (40, 40, 60),
        "text": (220, 220, 255),
        "ui_bg": (30, 30, 50),
        "ui_border": (100, 100, 150),
        "button": (40, 40, 80),
        "button_hover": (60, 60, 100),
        "button_text": (200, 200, 255),
        "blocks": [
            (0, 230, 230),  # I - ネオンシアン
            (230, 230, 0),  # O - ネオンイエロー
            (200, 0, 200),  # T - ネオンパープル
            (0, 0, 230),  # J - ネオンブルー
            (230, 130, 0),  # L - ネオンオレンジ
            (0, 230, 0),  # S - ネオングリーン
            (230, 0, 0),  # Z - ネオンレッド
        ],
    },
    "retro": {
        "background": (20, 40, 20),
        "grid_bg": (30, 50, 30),
        "grid_line": (50, 70, 50),
        "text": (180, 230, 180),
        "ui_bg": (40, 60, 40),
        "ui_border": (80, 120, 80),
        "button": (60, 90, 60),
        "button_hover": (80, 110, 80),
        "button_text": (200, 255, 200),
        "blocks": [
            (100, 200, 100),  # I - レトログリーン
            (180, 200, 100),  # O - レトロイエロー
            (150, 100, 150),  # T - レトロパープル
            (100, 100, 200),  # J - レトロブルー
            (200, 150, 100),  # L - レトロオレンジ
            (120, 200, 120),  # S - レトログリーン
            (200, 100, 100),  # Z - レトロレッド
        ],
    },
    "midnight": {
        "background": (5, 5, 15),
        "grid_bg": (10, 10, 30),
        "grid_line": (20, 20, 50),
        "text": (150, 150, 255),
        "ui_bg": (15, 15, 40),
        "ui_border": (30, 30, 80),
        "button": (25, 25, 60),
        "button_hover": (35, 35, 80),
        "button_text": (180, 180, 255),
        "blocks": [
            (80, 180, 255),  # I - ミッドナイトブルー
            (220, 220, 150),  # O - ミッドナイトイエロー
            (180, 100, 220),  # T - ミッドナイトパープル
            (80, 100, 255),  # J - ミッドナイトブルー
            (255, 140, 80),  # L - ミッドナイトオレンジ
            (100, 220, 100),  # S - ミッドナイトグリーン
            (255, 100, 120),  # Z - ミッドナイトレッド
        ],
    },
    "candy": {
        "background": (250, 240, 250),
        "grid_bg": (240, 230, 240),
        "grid_line": (230, 220, 230),
        "text": (80, 50, 80),
        "ui_bg": (245, 235, 245),
        "ui_border": (200, 180, 200),
        "button": (220, 200, 220),
        "button_hover": (230, 210, 230),
        "button_text": (100, 70, 100),
        "blocks": [
            (100, 200, 255),  # I - キャンディブルー
            (255, 230, 100),  # O - キャンディイエロー
            (220, 120, 220),  # T - キャンディパープル
            (130, 130, 255),  # J - キャンディブルー
            (255, 180, 120),  # L - キャンディオレンジ
            (120, 230, 120),  # S - キャンディグリーン
            (255, 120, 150),  # Z - キャンディレッド
        ],
    },
}

# 現在のテーマ
current_theme = "classic"
theme = THEMES[current_theme]

# フォント初期化
try:
    # 日本語対応フォント
    font = pygame.font.SysFont("notosanscjkjp", 28)
    small_font = pygame.font.SysFont("notosanscjkjp", 20)
    big_font = pygame.font.SysFont("notosanscjkjp", 36)
    title_font = pygame.font.SysFont("notosanscjkjp", 48)
except:
    try:
        # Windows 10以降のフォント
        font = pygame.font.SysFont("yugothicuisemibold", 28)
        small_font = pygame.font.SysFont("yugothicuisemibold", 20)
        big_font = pygame.font.SysFont("yugothicuisemibold", 36)
        title_font = pygame.font.SysFont("yugothicuisemibold", 48)
    except:
        try:
            # macOSのフォント
            font = pygame.font.SysFont("hiragino sans", 28)
            small_font = pygame.font.SysFont("hiragino sans", 20)
            big_font = pygame.font.SysFont("hiragino sans", 36)
            title_font = pygame.font.SysFont("hiragino sans", 48)
        except:
            # フォールバック
            print("日本語フォントが見つかりません。デフォルトフォントを使用します。")
            font = pygame.font.SysFont(None, 28)
            small_font = pygame.font.SysFont(None, 20)
            big_font = pygame.font.SysFont(None, 36)
            title_font = pygame.font.SysFont(None, 48)


# フォント初期化関数
def init_fonts():
    global font, small_font, big_font, title_font

    # スケールファクターに基づいたフォントサイズの計算
    font_size = int(28 * scale_factor)
    small_font_size = int(20 * scale_factor)
    big_font_size = int(36 * scale_factor)
    title_font_size = int(48 * scale_factor)

    try:
        # カスタムフォント「MoralerspaceNF」を使用
        font_path = "MoralerspaceNF_v1.1.0/MoralerspaceNeonNF-Regular.ttf"
        bold_font_path = "MoralerspaceNF_v1.1.0/MoralerspaceNeonNF-Bold.ttf"

        # 通常フォント
        font = pygame.font.Font(font_path, font_size)
        small_font = pygame.font.Font(font_path, small_font_size)

        # 太字フォント
        big_font = pygame.font.Font(bold_font_path, big_font_size)
        title_font = pygame.font.Font(bold_font_path, title_font_size)

        print("MoralerspaceNeonNFフォントを使用しています。")
    except Exception as e:
        print(f"カスタムフォント読み込みエラー: {e}")
        try:
            # 日本語対応フォント（MS Gothic）
            font = pygame.font.SysFont("msgothic", font_size)
            small_font = pygame.font.SysFont("msgothic", small_font_size)
            big_font = pygame.font.SysFont("msgothic", big_font_size)
            title_font = pygame.font.SysFont("msgothic", title_font_size)
            print("MS Gothicフォントを使用しています。")
        except:
            # フォールバック
            print("日本語フォントが見つかりません。デフォルトフォントを使用します。")
            font = pygame.font.SysFont(None, font_size)
            small_font = pygame.font.SysFont(None, small_font_size)
            big_font = pygame.font.SysFont(None, big_font_size)
            title_font = pygame.font.SysFont(None, title_font_size)


# サウンド初期化
move_sound = None
rotate_sound = None
drop_sound = None
clear_sound = None
tetris_sound = None
level_up_sound = None
hold_sound = None
game_over_sound = None

try:
    move_sound = mixer.Sound("assets/move.wav")
    rotate_sound = mixer.Sound("assets/rotate.wav")
    drop_sound = mixer.Sound("assets/drop.wav")
    clear_sound = mixer.Sound("assets/clear.wav")
    tetris_sound = mixer.Sound("assets/tetris.wav")
    level_up_sound = mixer.Sound("assets/level_up.wav")
    hold_sound = mixer.Sound("assets/hold.wav")
    game_over_sound = mixer.Sound("assets/game_over.wav")
    click_sound = mixer.Sound("assets/click.wav")

    # 音量調整
    move_sound.set_volume(0.5)
    rotate_sound.set_volume(0.5)
    drop_sound.set_volume(0.5)
    clear_sound.set_volume(0.7)
    tetris_sound.set_volume(0.7)
    level_up_sound.set_volume(0.7)
    hold_sound.set_volume(0.5)
    game_over_sound.set_volume(0.7)
    click_sound.set_volume(0.5)

    has_sound = True
except:
    print("音声ファイルが見つかりません。サウンドは無効になります。")
    has_sound = False

# BGM初期化
has_music = False
try:
    pygame.mixer.music.load("assets/tetris_theme.mp3")
    pygame.mixer.music.set_volume(0.5)
    has_music = True
except Exception as e:
    print(f"音声ファイルの読み込みエラー: {e}")

    # 音声ファイルがない場合のダミーオブジェクト
    class DummySound:
        def play(self):
            pass

        def set_volume(self, vol):
            pass

    click_sound = DummySound()
    move_sound = DummySound()
    rotate_sound = DummySound()
    drop_sound = DummySound()
    clear_sound = DummySound()
    tetris_sound = DummySound()
    level_up_sound = DummySound()
    game_over_sound = DummySound()
    hold_sound = DummySound()


# 設定の読み込み
def load_settings():
    try:
        with open("saves/settings.json", "r") as f:
            return json.load(f)
    except:
        # デフォルト設定
        return {
            "theme": "classic",
            "music": True,
            "sound": True,
            "ghost_piece": True,
            "effects": True,  # エフェクト表示
            "das": 0.17,  # Delayed Auto Shift (秒)
            "arr": 0.03,  # Auto Repeat Rate (秒)
        }


# 設定の保存
def save_settings(settings):
    with open("saves/settings.json", "w") as f:
        json.dump(settings, f)


# ハイスコアの読み込み
def load_high_scores():
    try:
        with open("saves/high_scores.json", "r") as f:
            return json.load(f)
    except:
        # 空のハイスコアデータ
        return {"marathon": [], "sprint": [], "ultra": []}


# ハイスコアの保存
def save_high_scores(high_scores):
    with open("saves/high_scores.json", "w") as f:
        json.dump(high_scores, f)


# 設定を読み込み
settings = load_settings()
current_theme = settings.get("theme", "classic")
theme = THEMES[current_theme]


# テーマの切り替え
def cycle_theme():
    global current_theme, theme, settings

    themes = list(THEMES.keys())
    current_index = themes.index(current_theme)
    next_index = (current_index + 1) % len(themes)
    current_theme = themes[next_index]
    theme = THEMES[current_theme]

    # 設定を更新
    settings["theme"] = current_theme
    save_settings(settings)


# フルスクリーン切替
def toggle_fullscreen():
    global FULLSCREEN, screen, screen_width, screen_height, grid_x, grid_y, scale_factor, settings

    FULLSCREEN = not FULLSCREEN

    if FULLSCREEN:
        # フルスクリーンモード
        screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
        info = pygame.display.Info()
        screen_width = info.current_w
        screen_height = info.current_h

        # スケール係数の計算
        width_scale = screen_width / BASE_SCREEN_WIDTH
        height_scale = screen_height / BASE_SCREEN_HEIGHT
        scale_factor = min(width_scale, height_scale)
    else:
        # ウィンドウモード
        screen_width = BASE_SCREEN_WIDTH
        screen_height = BASE_SCREEN_HEIGHT
        screen = pygame.display.set_mode((screen_width, screen_height))
        scale_factor = 1.0

    # グリッド位置の再計算
    grid_x = (screen_width - GRID_WIDTH * BLOCK_SIZE * scale_factor) // 2
    grid_y = (screen_height - GRID_HEIGHT * BLOCK_SIZE * scale_factor) // 2

    # 設定を更新
    settings["fullscreen"] = FULLSCREEN
    save_settings(settings)


# スクリーンの初期化
def initialize_screen(fullscreen=False):
    global screen, screen_width, screen_height, grid_x, grid_y, scale_factor, FULLSCREEN

    FULLSCREEN = fullscreen

    if fullscreen:
        # フルスクリーンモード
        info = pygame.display.Info()
        screen_width = info.current_w
        screen_height = info.current_h
        screen = pygame.display.set_mode(
            (screen_width, screen_height), pygame.FULLSCREEN
        )

        # スケール係数の計算
        width_scale = screen_width / BASE_SCREEN_WIDTH
        height_scale = screen_height / BASE_SCREEN_HEIGHT
        scale_factor = min(width_scale, height_scale)
    else:
        # ウィンドウモード
        screen_width = BASE_SCREEN_WIDTH
        screen_height = BASE_SCREEN_HEIGHT
        screen = pygame.display.set_mode((screen_width, screen_height))
        scale_factor = 1.0

    # グリッド位置の再計算
    grid_x = (screen_width - GRID_WIDTH * BLOCK_SIZE * scale_factor) // 2
    grid_y = (screen_height - GRID_HEIGHT * BLOCK_SIZE * scale_factor) // 2

    pygame.display.set_caption("テトリス")

    return screen


# テトロミノ形状の定義
TETROMINOS = [
    {"shape": [[1, 1, 1, 1]], "color": 0},  # I - シアン
    {"shape": [[1, 1], [1, 1]], "color": 1},  # O - イエロー
    {"shape": [[0, 1, 0], [1, 1, 1]], "color": 2},  # T - パープル
    {"shape": [[1, 0, 0], [1, 1, 1]], "color": 3},  # J - ブルー
    {"shape": [[0, 0, 1], [1, 1, 1]], "color": 4},  # L - オレンジ
    {"shape": [[0, 1, 1], [1, 1, 0]], "color": 5},  # S - グリーン
    {"shape": [[1, 1, 0], [0, 1, 1]], "color": 6},  # Z - レッド
]

# SRS (Super Rotation System) のキック定義
# 通常のミノ（JLSTZ）用キックテーブル
KICKS = {
    # 0->1 (A->B): 0度から90度（右回転）
    "01": [(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
    # 1->2 (B->C): 90度から180度（右回転）
    "12": [(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
    # 2->3 (C->D): 180度から270度（右回転）
    "23": [(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
    # 3->0 (D->A): 270度から0度（右回転）
    "30": [(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
    # 1->0 (B->A): 90度から0度（左回転）
    "10": [(0, 0), (1, 0), (1, 1), (0, -2), (1, -2)],
    # 2->1 (C->B): 180度から90度（左回転）
    "21": [(0, 0), (-1, 0), (-1, -1), (0, 2), (-1, 2)],
    # 3->2 (D->C): 270度から180度（左回転）
    "32": [(0, 0), (-1, 0), (-1, 1), (0, -2), (-1, -2)],
    # 0->3 (A->D): 0度から270度（左回転）
    "03": [(0, 0), (1, 0), (1, -1), (0, 2), (1, 2)],
}

# I型の特殊キックテーブル
I_KICKS = {
    # 0->1 (A->B): 0度から90度（右回転）
    "01": [(0, 0), (-2, 0), (1, 0), (-2, -1), (1, 2)],
    # 1->2 (B->C): 90度から180度（右回転）
    "12": [(0, 0), (-1, 0), (2, 0), (-1, 2), (2, -1)],
    # 2->3 (C->D): 180度から270度（右回転）
    "23": [(0, 0), (2, 0), (-1, 0), (2, 1), (-1, -2)],
    # 3->0 (D->A): 270度から0度（右回転）
    "30": [(0, 0), (1, 0), (-2, 0), (1, -2), (-2, 1)],
    # 1->0 (B->A): 90度から0度（左回転）
    "10": [(0, 0), (1, 0), (-2, 0), (1, -2), (-2, 1)],
    # 2->1 (C->B): 180度から90度（左回転）
    "21": [(0, 0), (2, 0), (-1, 0), (2, 1), (-1, -2)],
    # 3->2 (D->C): 270度から180度（左回転）
    "32": [(0, 0), (-1, 0), (2, 0), (-1, 2), (2, -1)],
    # 0->3 (A->D): 0度から270度（左回転）
    "03": [(0, 0), (-2, 0), (1, 0), (-2, -1), (1, 2)],
}


# ボタンクラス
class Button:
    def __init__(
        self, x, y, width, height, text, action=None, bg_color=None, text_color=None
    ):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.action = action
        self.bg_color = bg_color or theme["button"]
        self.hover_color = theme["button_hover"]
        self.text_color = text_color or theme["button_text"]
        self.is_hovered = False
        self.font = font

    def update(self, mouse_pos):
        self.is_hovered = self.rect.collidepoint(mouse_pos)

    def draw(self, surface):
        color = self.hover_color if self.is_hovered else self.bg_color
        pygame.draw.rect(surface, color, self.rect)
        pygame.draw.rect(surface, theme["ui_border"], self.rect, 2)

        text_surf = self.font.render(self.text, True, self.text_color)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.rect.collidepoint(event.pos):
                if click_sound and has_sound and settings.get("sound", True):
                    click_sound.play()
                if self.action:
                    return self.action() if callable(self.action) else self.action
        return None


# パーティクルクラス
class Particle:
    def __init__(self, x, y, color, size=3, speed=2, life=1.0):
        self.x = x
        self.y = y
        self.color = color
        self.size = size
        self.speed = speed
        self.life = life
        self.max_life = life
        self.angle = random.uniform(0, 2 * math.pi)
        self.dx = math.cos(self.angle) * self.speed
        self.dy = math.sin(self.angle) * self.speed

    def update(self, dt):
        self.x += self.dx * dt * 60
        self.y += self.dy * dt * 60
        self.life -= dt
        return self.life > 0

    def draw(self, surface):
        alpha = int(255 * (self.life / self.max_life))
        color = (
            (*self.color[:3], alpha) if len(self.color) > 3 else (*self.color, alpha)
        )
        size = int(self.size * (self.life / self.max_life))
        pygame.draw.circle(surface, color, (int(self.x), int(self.y)), max(1, size))


# パーティクルシステムクラス
class ParticleSystem:
    def __init__(self):
        self.particles = []

    def create_explosion(self, x, y, color, count=10):
        for _ in range(count):
            size = random.uniform(2, 5)
            speed = random.uniform(1, 3)
            life = random.uniform(0.5, 1.5)
            self.particles.append(Particle(x, y, color, size, speed, life))

    def update(self, dt):
        self.particles = [p for p in self.particles if p.update(dt)]

    def draw(self, surface):
        for particle in self.particles:
            particle.draw(surface)


# フローティングテキストクラス
class FloatingText:
    def __init__(self, x, y, text, color, size=28, life=1.5):
        self.x = x
        self.y = y
        self.text = text
        self.color = color
        self.life = life
        self.max_life = life
        self.font = pygame.font.SysFont("notosanscjkjp", size)
        self.dy = -1  # 上に移動

    def update(self, dt):
        self.y += self.dy * dt * 60
        self.life -= dt
        return self.life > 0

    def draw(self, surface):
        alpha = int(255 * (self.life / self.max_life))
        text_surf = self.font.render(self.text, True, self.color)
        text_surf.set_alpha(alpha)
        surface.blit(text_surf, (self.x - text_surf.get_width() // 2, self.y))


# テトリスクラス
class Tetris:
    def __init__(self, game_mode="marathon"):
        self.game_mode = game_mode
        self.reset()

        # ゲームモードに応じた設定
        if game_mode == "sprint":
            self.lines_target = 40
            self.time_limit = None
        elif game_mode == "ultra":
            self.lines_target = None
            self.time_limit = 180  # 3分
        else:  # marathon
            self.lines_target = None
            self.time_limit = None

        # パーティクルシステムの初期化
        self.particle_system = ParticleSystem()

        # フローティングテキストのリスト
        self.floating_texts = []

        # ピース統計
        self.pieces_stats = [0] * 7
        self.tspin_count = 0

        # ゲームクリアフラグ
        self.game_clear = False

        # ハイスコアをチェック
        self.high_scores = load_high_scores().get(game_mode, [])

        # DAS/ARR設定
        self.das_delay = settings.get("das", 0.17)  # 秒
        self.arr_delay = settings.get("arr", 0.03)  # 秒
        self.das_timer = 0
        self.arr_timer = 0

    def reset(self):
        # ゲームの状態を初期化
        self.grid = [[None for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
        self.current_piece = None
        self.held_piece = None
        self.can_hold = True
        self.has_used_hold = False
        self.next_pieces = [self.get_next_piece() for _ in range(5)]
        self.game_over = False
        self.game_clear = False
        self.paused = False
        self.soft_drop = False

        # 次のピースを取得
        self.current_piece = self.next_pieces.pop(0)
        self.next_pieces.append(self.get_next_piece())

        # ゴーストピースの初期化
        self.ghost_piece = self.get_ghost_piece()

        # スコアと関連情報
        self.score = 0
        self.level = 1
        self.lines_cleared = 0
        self.combo = 0
        self.back_to_back = False

        # 落下速度と時間変数
        self.fall_time = 0
        self.fall_speed = 0.8  # 初期落下速度（秒）
        self.lock_delay = 0
        self.max_lock_delay = 0.5  # 接地からロックまでの最大時間（秒）

        # ゲーム時間
        self.time_played = 0

        # ラインクリア用
        self.clearing_lines = False
        self.lines_to_clear = []

    def get_next_piece(self):
        # 次のピースをランダムに選択
        piece_index = random.randint(0, len(TETROMINOS) - 1)
        piece = {
            "shape": [row[:] for row in TETROMINOS[piece_index]["shape"]],
            "color": theme["blocks"][TETROMINOS[piece_index]["color"]],
            "x": GRID_WIDTH // 2 - len(TETROMINOS[piece_index]["shape"][0]) // 2,
            "y": 0,
            "rotation": 0,
            "index": piece_index,
        }
        return piece

    def get_ghost_piece(self):
        if not self.current_piece or not settings.get("ghost_piece", True):
            return None

        # 現在のピースの深いコピー
        ghost = {
            "shape": [row[:] for row in self.current_piece["shape"]],
            "color": self.current_piece["color"],
            "x": self.current_piece["x"],
            "y": self.current_piece["y"],
            "rotation": self.current_piece["rotation"],
        }

        # 可能な限り下に移動
        while self.valid_move(ghost, y_offset=1):
            ghost["y"] += 1

        return ghost

    def valid_move(self, piece, x_offset=0, y_offset=0, new_shape=None):
        # 移動や回転が有効かチェック
        if not piece:
            return False

        shape_to_check = new_shape if new_shape else piece["shape"]

        for y, row in enumerate(shape_to_check):
            for x, cell in enumerate(row):
                if cell:
                    new_x = piece["x"] + x + x_offset
                    new_y = piece["y"] + y + y_offset

                    # 範囲チェック
                    if new_x < 0 or new_x >= GRID_WIDTH or new_y >= GRID_HEIGHT:
                        return False

                    # 既存ブロックとの衝突チェック（グリッド内の場合のみ）
                    if new_y >= 0 and self.grid[new_y][new_x] is not None:
                        return False

        return True

    def rotate(self, clockwise=True):
        if self.game_over or self.paused or not self.current_piece:
            return

        if has_sound and settings.get("sound", True):
            rotate_sound.play()

        # 元の状態を保存
        original_rotation = self.current_piece["rotation"]
        original_shape = [row[:] for row in self.current_piece["shape"]]
        original_x = self.current_piece["x"]
        original_y = self.current_piece["y"]

        # 新しい回転状態を計算
        if clockwise:
            new_rotation = (original_rotation + 1) % 4
            # 回転の実行
            self.current_piece["shape"] = self.rotate_matrix(original_shape)
        else:
            new_rotation = (original_rotation - 1) % 4
            # 反時計回りの場合は3回時計回りに回転させる
            for _ in range(3):
                self.current_piece["shape"] = self.rotate_matrix(
                    self.current_piece["shape"]
                )

        self.current_piece["rotation"] = new_rotation

        # デバッグ情報：現在のピースの位置と回転状態
        print(f"回転前: x={original_x}, y={original_y}, rotation={original_rotation}")
        print(
            f"回転後: x={self.current_piece['x']}, y={self.current_piece['y']}, rotation={new_rotation}"
        )

        # 壁や他のブロックとの衝突をチェック
        # まず基本的な位置で回転が可能かチェック
        if self.valid_move(self.current_piece):
            print("基本位置で回転可能")
            # T-Spinチェック
            if self.current_piece["index"] == 2:  # T型
                self.check_tspin()

            # ゴーストピースの更新
            self.ghost_piece = self.get_ghost_piece()
            return

        print("基本位置で回転不可能、キックテスト実行")
        # 基本位置で回転できない場合、キックテストを実行
        # キック用のパターンキー
        kick_key = f"{original_rotation}{new_rotation}"
        print(f"キックキー: {kick_key}")

        # I型ピースと他の形状で異なるキックパターンを使用
        if self.current_piece["index"] == 0:  # I型
            kicks = I_KICKS[kick_key]
            print(f"I型キックパターン: {kicks}")
        else:
            kicks = KICKS[kick_key]
            print(f"通常キックパターン: {kicks}")

        # キックテストを実行
        for i, (kick_x, kick_y) in enumerate(kicks):
            print(f"キックテスト {i+1}: ({kick_x}, {kick_y})")
            if self.valid_move(self.current_piece, x_offset=kick_x, y_offset=kick_y):
                print(f"キックテスト {i+1} 成功")
                self.current_piece["x"] += kick_x
                self.current_piece["y"] += kick_y
                print(
                    f"新しい位置: x={self.current_piece['x']}, y={self.current_piece['y']}"
                )

                # T-Spinチェック
                if self.current_piece["index"] == 2:  # T型
                    self.check_tspin()

                # ゴーストピースの更新
                self.ghost_piece = self.get_ghost_piece()
                return

        # 回転が不可能な場合は元に戻す
        self.current_piece["shape"] = original_shape
        self.current_piece["rotation"] = original_rotation
        self.current_piece["x"] = original_x
        self.current_piece["y"] = original_y

    def rotate_matrix(self, matrix):
        # 行列の回転
        return [list(row) for row in zip(*reversed(matrix))]

    def draw_game_clear_screen(self):
        # 半透明のオーバーレイ
        overlay = pygame.Surface((screen_width, screen_height), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        screen.blit(overlay, (0, 0))

        # メニューパネル
        panel_width = 400 * scale_factor
        panel_height = 400 * scale_factor
        panel_x = (screen_width - panel_width) // 2
        panel_y = (screen_height - panel_height) // 2

        pygame.draw.rect(
            screen, theme["ui_bg"], (panel_x, panel_y, panel_width, panel_height)
        )
        pygame.draw.rect(
            screen, theme["ui_border"], (panel_x, panel_y, panel_width, panel_height), 3
        )

        # タイトル
        title_text = title_font.render("ゲームクリア！", True, (100, 255, 100))
        screen.blit(
            title_text,
            (
                screen_width // 2 - title_text.get_width() // 2,
                panel_y + 30 * scale_factor,
            ),
        )

        # 結果表示
        score_text = font.render(f"スコア: {self.score}", True, theme["text"])
        level_text = font.render(f"レベル: {self.level}", True, theme["text"])
        lines_text = font.render(f"ライン: {self.lines_cleared}", True, theme["text"])

        time_minutes = int(self.time_played // 60)
        time_seconds = int(self.time_played % 60)
        time_text = font.render(
            f"クリア時間: {time_minutes}:{time_seconds:02d}", True, theme["text"]
        )

        # ハイスコア？
        is_high_score = self.check_high_score()

        if is_high_score:
            high_score_text = font.render("新記録達成！", True, (255, 255, 100))
            screen.blit(
                high_score_text,
                (
                    screen_width // 2 - high_score_text.get_width() // 2,
                    panel_y + 80 * scale_factor,
                ),
            )

        screen.blit(
            score_text,
            (
                screen_width // 2 - score_text.get_width() // 2,
                panel_y + 120 * scale_factor,
            ),
        )
        screen.blit(
            level_text,
            (
                screen_width // 2 - level_text.get_width() // 2,
                panel_y + 160 * scale_factor,
            ),
        )
        screen.blit(
            lines_text,
            (
                screen_width // 2 - lines_text.get_width() // 2,
                panel_y + 200 * scale_factor,
            ),
        )
        screen.blit(
            time_text,
            (
                screen_width // 2 - time_text.get_width() // 2,
                panel_y + 240 * scale_factor,
            ),
        )

        # リトライボタン
        retry_button = Button(
            panel_x + panel_width // 2 - 100 * scale_factor,
            panel_y + 300 * scale_factor,
            200 * scale_factor,
            40 * scale_factor,
            "リトライ",
            action=lambda: "retry",
        )

        menu_button = Button(
            panel_x + panel_width // 2 - 100 * scale_factor,
            panel_y + 350 * scale_factor,
            200 * scale_factor,
            40 * scale_factor,
            "メニューに戻る",
            action=lambda: "menu",
        )

        mouse_pos = pygame.mouse.get_pos()
        retry_button.update(mouse_pos)
        retry_button.draw(screen)

        menu_button.update(mouse_pos)
        menu_button.draw(screen)

        return [retry_button, menu_button]

    def update(self, dt):
        """ゲームの状態を更新する"""
        if self.game_over or self.paused:
            return

        # ゲーム時間の更新
        self.time_played += dt

        # 時間制限のチェック（ウルトラモード）
        if self.time_limit and self.time_played >= self.time_limit:
            self.game_over = True
            return

        # パーティクルとフローティングテキストの更新
        self.particle_system.update(dt)
        self.floating_texts = [text for text in self.floating_texts if text.update(dt)]

        # 落下処理
        self.fall_time += dt
        fall_speed = self.fall_speed / (
            1 + (self.soft_drop * 9)
        )  # ソフトドロップで10倍速く

        if self.fall_time >= fall_speed:
            self.fall_time = 0
            # 下に移動できるかチェック
            if self.valid_move(self.current_piece, y_offset=1):
                self.current_piece["y"] += 1
                # ロックディレイをリセット
                self.lock_delay = 0
            else:
                # 接地している場合、ロックディレイを増加
                self.lock_delay += dt
                if self.lock_delay >= self.max_lock_delay:
                    self.lock_piece()

        # キー長押し処理（DAS/ARR）
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT] or keys[pygame.K_RIGHT]:
            direction = -1 if keys[pygame.K_LEFT] else 1

            # DASタイマーの更新
            if self.das_timer < self.das_delay:
                self.das_timer += dt
            else:
                # ARRタイマーの更新
                self.arr_timer += dt
                while self.arr_timer >= self.arr_delay:
                    self.move(direction)
                    self.arr_timer -= self.arr_delay
        else:
            # キーが押されていない場合はタイマーをリセット
            self.das_timer = 0
            self.arr_timer = 0

    def move(self, direction):
        """ピースを左右に移動する"""
        if self.game_over or self.paused or not self.current_piece:
            return False

        if self.valid_move(self.current_piece, x_offset=direction):
            self.current_piece["x"] += direction
            # ゴーストピースの更新
            self.ghost_piece = self.get_ghost_piece()

            # 効果音
            if move_sound and has_sound and settings.get("sound", True):
                move_sound.play()

            return True
        return False

    def lock_piece(self):
        """現在のピースをグリッドに固定する"""
        # グローバル宣言を削除

        # T-Spinチェック
        tspin_type = self.check_tspin()

        # ピースが存在しない場合は何もしない
        if not self.current_piece:
            return

        # 現在のピースをグリッドに追加
        for y, row in enumerate(self.current_piece["shape"]):
            for x, cell in enumerate(row):
                if cell:
                    block_grid_y = self.current_piece["y"] + y
                    block_grid_x = self.current_piece["x"] + x

                    # グリッド範囲内かチェック
                    if (
                        0 <= block_grid_y < GRID_HEIGHT
                        and 0 <= block_grid_x < GRID_WIDTH
                    ):
                        self.grid[block_grid_y][block_grid_x] = self.current_piece[
                            "color"
                        ]

                        # ブロック配置エフェクト（設定がONの場合）
                        if settings.get("effects", True):
                    # パーティクルエフェクト
                            # 画面上の実際の座標を計算
                            block_screen_x = (
                                grid_x + block_grid_x * BLOCK_SIZE * scale_factor
                            )
                            block_screen_y = (
                                grid_y + block_grid_y * BLOCK_SIZE * scale_factor
                            )

                            # ブロックの中心にエフェクトを配置
                    self.particle_system.create_explosion(
                        block_screen_x + (BLOCK_SIZE * scale_factor / 2),
                        block_screen_y + (BLOCK_SIZE * scale_factor / 2),
                        self.current_piece["color"],
                        5,  # パーティクル数
                    )

        # 効果音
        if drop_sound and has_sound and settings.get("sound", True):
            drop_sound.play()

        # ピース統計の更新
        self.pieces_stats[self.current_piece["index"]] += 1

        # ラインクリアチェック
        self.check_lines()

        # ホールドリセット
        self.can_hold = True

        # 次のピースを取得
        self.current_piece = self.next_pieces.pop(0)
        self.next_pieces.append(self.get_next_piece())

        # ゴーストピースの更新
        self.ghost_piece = self.get_ghost_piece()

        # ゲームオーバーチェック（新しいピースが配置できない場合）
        if not self.valid_move(self.current_piece):
            self.game_over = True
            if game_over_sound and has_sound and settings.get("sound", True):
                game_over_sound.play()

    def check_lines(self):
        """完成したラインをチェックして消去する"""
        lines_to_clear = []
        clear_sound_to_play = None  # 変数を初期化

        # 完成したラインを探す
        for y in range(GRID_HEIGHT):
            if all(cell is not None for cell in self.grid[y]):
                lines_to_clear.append(y)

        if not lines_to_clear:
            # ラインがクリアされなかった場合はコンボをリセット
            self.combo = 0
            self.back_to_back = False
            return

        # ラインクリア数に応じたスコア計算
        lines_count = len(lines_to_clear)
        self.lines_cleared += lines_count

        # レベルアップチェック（10ライン毎）
        old_level = self.level
        self.level = max(1, self.lines_cleared // 10 + 1)

        # レベルアップ時の処理
        if self.level > old_level:
            # 落下速度の更新（レベルが上がるほど速くなる）
            self.fall_speed = max(0.05, 0.8 - (self.level - 1) * 0.05)

            # レベルアップ効果音
            if level_up_sound and has_sound and settings.get("sound", True):
                level_up_sound.play()

            # レベルアップテキスト表示
            self.floating_texts.append(
                FloatingText(
                    screen_width // 2,
                    screen_height // 2,
                    f"レベルアップ! {self.level}",
                    (255, 255, 100),
                    36,
                    3.0,  # 表示時間を延長
                )
            )

        # コンボ数の更新
        self.combo += 1

        # スコア計算（レベルとコンボに応じて増加）
        base_score = 0
        if lines_count == 1:
            base_score = 100
            clear_sound_to_play = clear_sound
        elif lines_count == 2:
            base_score = 300
            clear_sound_to_play = clear_sound
        elif lines_count == 3:
            base_score = 500
            clear_sound_to_play = clear_sound
        elif lines_count == 4:
            base_score = 800
            clear_sound_to_play = tetris_sound
            # テトリス（4ライン消し）の場合はBack-to-Backを更新
            if self.back_to_back:
                base_score = int(base_score * 1.5)  # Back-to-Backボーナス
            self.back_to_back = True

        # T-Spinボーナス
        t_spin_bonus = 1
        if hasattr(self, "is_tspin") and self.is_tspin:
            t_spin_bonus = 2
            self.tspin_count += 1
            self.back_to_back = True

        # コンボボーナス（最大100%）
        combo_bonus = min(1.0, self.combo * 0.1)

        # 最終スコア計算
        score_gain = int(base_score * self.level * (1 + combo_bonus) * t_spin_bonus)
        self.score += score_gain

        # スコア獲得テキスト表示
        self.floating_texts.append(
            FloatingText(
                grid_x + GRID_WIDTH * BLOCK_SIZE * scale_factor // 2,
                grid_y + lines_to_clear[0] * BLOCK_SIZE * scale_factor,
                f"+{score_gain}",
                (255, 255, 100),
                28,
                2.5,  # 表示時間を延長
            )
        )
        # コンボテキスト表示（2コンボ以上）
        if self.combo > 1:
            self.floating_texts.append(
                FloatingText(
                    grid_x + GRID_WIDTH * BLOCK_SIZE * scale_factor // 2,
                    grid_y + lines_to_clear[0] * BLOCK_SIZE * scale_factor + 30,
                    f"{self.combo} Combo!",  # 英語表記に変更
                    (100, 255, 255),
                    24,
                    2.5,  # 表示時間を延長
                )
            )

        # 効果音
        if clear_sound_to_play and has_sound and settings.get("sound", True):
            clear_sound_to_play.play()

        # パーティクルエフェクト
        for y in lines_to_clear:
            for x in range(GRID_WIDTH):
                if self.grid[y][x]:
                    self.particle_system.create_explosion(
                        grid_x + (x + 0.5) * BLOCK_SIZE * scale_factor,
                        grid_y + (y + 0.5) * BLOCK_SIZE * scale_factor,
                        self.grid[y][x],
                        15,
                    )

        # ラインを消去して上のブロックを落とす
        for y in sorted(lines_to_clear, reverse=True):
            # ラインを消去
            self.grid.pop(y)
            # 新しい空のラインを上に追加
            self.grid.insert(0, [None for _ in range(GRID_WIDTH)])

        # スプリントモードのクリア条件チェック
        if self.game_mode == "sprint" and self.lines_cleared >= self.lines_target:
            self.game_clear = True

    def drop(self):
        """ピースを一番下まで落とす（ハードドロップ）"""
        if self.game_over or self.paused or not self.current_piece:
            return

        # 落下距離を計算（スコア計算用）
        drop_distance = 0

        # 可能な限り下に移動
        while self.valid_move(self.current_piece, y_offset=1):
            self.current_piece["y"] += 1
            drop_distance += 1

        # ハードドロップボーナス（2点/セル）
        self.score += drop_distance * 2

        # ピースを固定
        self.lock_piece()

    def hold_piece(self):
        """現在のピースをホールドする"""
        if self.game_over or self.paused or not self.current_piece or not self.can_hold:
            return

        # 効果音
        if hold_sound and has_sound and settings.get("sound", True):
            hold_sound.play()

        # 初回ホールドの場合
        if self.held_piece is None:
            self.held_piece = {
                "shape": [
                    row[:] for row in TETROMINOS[self.current_piece["index"]]["shape"]
                ],
                "color": theme["blocks"][
                    TETROMINOS[self.current_piece["index"]]["color"]
                ],
                "index": self.current_piece["index"],
                "rotation": 0,
            }
            # 次のピースを取得
            self.current_piece = self.next_pieces.pop(0)
            self.next_pieces.append(self.get_next_piece())
        else:
            # ホールドピースと現在のピースを交換
            temp = self.held_piece
            self.held_piece = {
                "shape": [
                    row[:] for row in TETROMINOS[self.current_piece["index"]]["shape"]
                ],
                "color": theme["blocks"][
                    TETROMINOS[self.current_piece["index"]]["color"]
                ],
                "index": self.current_piece["index"],
                "rotation": 0,
            }
            self.current_piece = {
                "shape": [row[:] for row in TETROMINOS[temp["index"]]["shape"]],
                "color": theme["blocks"][TETROMINOS[temp["index"]]["color"]],
                "x": GRID_WIDTH // 2 - len(TETROMINOS[temp["index"]]["shape"][0]) // 2,
                "y": 0,
                "rotation": 0,
                "index": temp["index"],
            }

        # ホールド使用フラグを設定
        self.can_hold = False
        self.has_used_hold = True

        # ゴーストピースの更新
        self.ghost_piece = self.get_ghost_piece()

    def check_tspin(self):
        """T-Spinの条件をチェックする"""
        if self.current_piece["index"] != 2:  # T型でない場合
            self.is_tspin = False
            return

        # T-Spinの条件：T型の4隅のうち3つ以上が埋まっている
        corners_filled = 0
        t_x, t_y = self.current_piece["x"], self.current_piece["y"]

        # T型の中心座標
        center_x = t_x + 1
        center_y = t_y + 1

        # 4隅の座標
        corners = [
            (center_x - 1, center_y - 1),  # 左上
            (center_x + 1, center_y - 1),  # 右上
            (center_x - 1, center_y + 1),  # 左下
            (center_x + 1, center_y + 1),  # 右下
        ]

        # 各隅が埋まっているかチェック
        for cx, cy in corners:
            if (
                cx < 0
                or cx >= GRID_WIDTH
                or cy < 0
                or cy >= GRID_HEIGHT
                or (cy >= 0 and cx >= 0 and self.grid[cy][cx] is not None)
            ):
                corners_filled += 1

        # T-Spinの条件：3つ以上の隅が埋まっている
        self.is_tspin = corners_filled >= 3

    def toggle_pause(self):
        """ゲームの一時停止/再開を切り替える"""
        self.paused = not self.paused

        # BGMの一時停止/再開
        if has_music and settings.get("music", True):
            if self.paused:
                pygame.mixer.music.pause()
            else:
                pygame.mixer.music.unpause()

    def draw(self):
        """ゲーム画面を描画する"""
        # 背景
        screen.fill(theme["background"])

        # グリッド背景
        pygame.draw.rect(
            screen,
            theme["grid_bg"],
            (
                grid_x,
                grid_y,
                GRID_WIDTH * BLOCK_SIZE * scale_factor,
                GRID_HEIGHT * BLOCK_SIZE * scale_factor,
            ),
        )

        # グリッドライン
        for x in range(GRID_WIDTH + 1):
            pygame.draw.line(
            screen,
                theme["grid_line"],
                (
                    grid_x + x * BLOCK_SIZE * scale_factor,
                    grid_y,
                ),
                (
                    grid_x + x * BLOCK_SIZE * scale_factor,
                    grid_y + GRID_HEIGHT * BLOCK_SIZE * scale_factor,
                ),
                1,
            )

        for y in range(GRID_HEIGHT + 1):
            pygame.draw.line(
                    screen,
                    theme["grid_line"],
                    (
                    grid_x,
                        grid_y + y * BLOCK_SIZE * scale_factor,
                ),
                (
                    grid_x + GRID_WIDTH * BLOCK_SIZE * scale_factor,
                    grid_y + y * BLOCK_SIZE * scale_factor,
                    ),
                    1,
                )

        # グリッド内のブロックを描画
        for y in range(GRID_HEIGHT):
            for x in range(GRID_WIDTH):
                if self.grid[y][x]:
                    self.draw_block(x, y, self.grid[y][x])

        # ゴーストピースの描画
        if self.ghost_piece and settings.get("ghost_piece", True):
            for y, row in enumerate(self.ghost_piece["shape"]):
                for x, cell in enumerate(row):
                    if cell:
                        ghost_x = self.ghost_piece["x"] + x
                        ghost_y = self.ghost_piece["y"] + y

                        # 半透明のゴーストピース
                        ghost_color = self.ghost_piece["color"]
                        if len(ghost_color) == 3:
                            ghost_color = (*ghost_color, 100)  # アルファ値を追加
                        else:
                            ghost_color = (*ghost_color[:3], 100)  # アルファ値を変更

                        # 枠線のみのブロック
                        block_rect = pygame.Rect(
                            grid_x + ghost_x * BLOCK_SIZE * scale_factor,
                            grid_y + ghost_y * BLOCK_SIZE * scale_factor,
                            BLOCK_SIZE * scale_factor,
                            BLOCK_SIZE * scale_factor,
                        )
                        pygame.draw.rect(screen, ghost_color, block_rect, 2)

        # 現在のピースの描画
        if self.current_piece:
            for y, row in enumerate(self.current_piece["shape"]):
                for x, cell in enumerate(row):
                    if cell:
                        self.draw_block(
                            self.current_piece["x"] + x,
                            self.current_piece["y"] + y,
                            self.current_piece["color"],
                        )

        # 次のピースの表示
        next_text = font.render("NEXT", True, theme["text"])
        screen.blit(
            next_text,
            (
                grid_x + (GRID_WIDTH * BLOCK_SIZE + 50) * scale_factor,
                grid_y + 20 * scale_factor,
            ),
        )

        for i, next_piece in enumerate(self.next_pieces[:3]):  # 次の3つのピースを表示
            next_x = grid_x + (GRID_WIDTH * BLOCK_SIZE + 80) * scale_factor
            next_y = grid_y + (80 + i * 80) * scale_factor

            # ピースの形状に応じて位置を調整
            offset_x = 0
            if next_piece["index"] == 0:  # I型
                offset_x = -0.5 * BLOCK_SIZE * scale_factor
            elif next_piece["index"] in [2, 3, 4]:  # T, J, L型
                offset_x = 0

            # 次のピースを描画
            for y, row in enumerate(next_piece["shape"]):
                for x, cell in enumerate(row):
                    if cell:
                        block_rect = pygame.Rect(
                            next_x + (x * BLOCK_SIZE + offset_x) * scale_factor,
                            next_y + y * BLOCK_SIZE * scale_factor,
                            BLOCK_SIZE * scale_factor,
                            BLOCK_SIZE * scale_factor,
                        )
                        pygame.draw.rect(screen, next_piece["color"], block_rect)
                        pygame.draw.rect(screen, theme["ui_border"], block_rect, 1)

        # ホールドピースの表示
        hold_text = font.render("HOLD", True, theme["text"])
        screen.blit(
            hold_text,
            (
                grid_x - 120 * scale_factor,
                grid_y + 20 * scale_factor,
            ),
        )

        if self.held_piece:
            hold_x = grid_x - 100 * scale_factor
            hold_y = grid_y + 80 * scale_factor

            # ピースの形状に応じて位置を調整
            offset_x = 0
            if self.held_piece["index"] == 0:  # I型
                offset_x = -0.5 * BLOCK_SIZE * scale_factor
            elif self.held_piece["index"] in [2, 3, 4]:  # T, J, L型
                offset_x = 0

            # ホールドピースを描画（使用済みの場合は半透明）
            for y, row in enumerate(self.held_piece["shape"]):
                for x, cell in enumerate(row):
                    if cell:
                        block_rect = pygame.Rect(
                            hold_x + (x * BLOCK_SIZE + offset_x) * scale_factor,
                            hold_y + y * BLOCK_SIZE * scale_factor,
                            BLOCK_SIZE * scale_factor,
                            BLOCK_SIZE * scale_factor,
                        )

                        # 使用済みの場合は半透明
            if not self.can_hold:
                            hold_color = (*self.held_piece["color"][:3], 128)
                            pygame.draw.rect(screen, hold_color, block_rect)
                        else:
                            pygame.draw.rect(
                                screen, self.held_piece["color"], block_rect
                            )

                        pygame.draw.rect(screen, theme["ui_border"], block_rect, 1)

        # スコア情報の表示
        score_x = grid_x - 150 * scale_factor
        score_y = grid_y + 200 * scale_factor

        score_text = font.render(f"スコア: {self.score}", True, theme["text"])
        level_text = font.render(f"レベル: {self.level}", True, theme["text"])
        lines_text = font.render(f"ライン: {self.lines_cleared}", True, theme["text"])

        # ゲームモードに応じた追加情報
        if self.game_mode == "sprint":
            # スプリントモード：残りライン数
            remaining = max(0, self.lines_target - self.lines_cleared)
            mode_text = font.render(f"残り: {remaining}ライン", True, theme["text"])
        elif self.game_mode == "ultra":
            # ウルトラモード：残り時間
            remaining = max(0, self.time_limit - self.time_played)
            minutes = int(remaining // 60)
            seconds = int(remaining % 60)
            mode_text = font.render(
                f"残り時間: {minutes}:{seconds:02d}", True, theme["text"]
            )
        else:
            # マラソンモード：プレイ時間
            minutes = int(self.time_played // 60)
            seconds = int(self.time_played % 60)
            mode_text = font.render(
                f"時間: {minutes}:{seconds:02d}", True, theme["text"]
            )

        screen.blit(score_text, (score_x, score_y))
        screen.blit(level_text, (score_x, score_y + 40 * scale_factor))
        screen.blit(lines_text, (score_x, score_y + 80 * scale_factor))
        screen.blit(mode_text, (score_x, score_y + 120 * scale_factor))

        # 操作説明
        controls_x = grid_x - 150 * scale_factor
        controls_y = grid_y + 350 * scale_factor

        controls = [
            "← → : 移動",
            "↓ : ソフトドロップ",
            "↑ : 回転（時計回り）",
            "Z : 回転（反時計回り）",
            "スペース : ハードドロップ",
            "C : ホールド",
            "P : 一時停止",
            "ESC : メニュー",
        ]

        for i, control in enumerate(controls):
            control_text = small_font.render(control, True, theme["text"])
            screen.blit(control_text, (controls_x, controls_y + i * 25 * scale_factor))

        # パーティクルの描画
        self.particle_system.draw(screen)

        # フローティングテキストの描画
        for text in self.floating_texts:
            text.draw(screen)

        # ゲームオーバー画面
        if self.game_over:
            return self.draw_game_over_screen()

        # ゲームクリア画面
        if self.game_clear:
            return self.draw_game_clear_screen()

        return None

    def draw_block(self, x, y, color):
        """ブロックを描画する"""
        block_rect = pygame.Rect(
            grid_x + x * BLOCK_SIZE * scale_factor,
            grid_y + y * BLOCK_SIZE * scale_factor,
            BLOCK_SIZE * scale_factor,
            BLOCK_SIZE * scale_factor,
        )
        pygame.draw.rect(screen, color, block_rect)
        pygame.draw.rect(screen, theme["ui_border"], block_rect, 1)

    def draw_game_over_screen(self):
        """ゲームオーバー画面を描画する"""
        # 半透明のオーバーレイ
        overlay = pygame.Surface((screen_width, screen_height), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        screen.blit(overlay, (0, 0))

        # メニューパネル
        panel_width = 400 * scale_factor
        panel_height = 400 * scale_factor
        panel_x = (screen_width - panel_width) // 2
        panel_y = (screen_height - panel_height) // 2

        pygame.draw.rect(
            screen, theme["ui_bg"], (panel_x, panel_y, panel_width, panel_height)
        )
        pygame.draw.rect(
            screen, theme["ui_border"], (panel_x, panel_y, panel_width, panel_height), 3
        )

        # タイトル
        title_text = title_font.render("ゲームオーバー", True, (255, 100, 100))
        screen.blit(
            title_text,
            (
                screen_width // 2 - title_text.get_width() // 2,
                panel_y + 30 * scale_factor,
            ),
        )

        # 結果表示
        score_text = font.render(f"スコア: {self.score}", True, theme["text"])
        level_text = font.render(f"レベル: {self.level}", True, theme["text"])
        lines_text = font.render(f"ライン: {self.lines_cleared}", True, theme["text"])

        time_minutes = int(self.time_played // 60)
        time_seconds = int(self.time_played % 60)
        time_text = font.render(
            f"プレイ時間: {time_minutes}:{time_seconds:02d}", True, theme["text"]
        )

        # ハイスコア？
        is_high_score = self.check_high_score()

        if is_high_score:
            # 新記録達成テキストを点滅させる
            if pygame.time.get_ticks() % 1000 < 800:  # 1秒のうち0.8秒間表示
                high_score_text = big_font.render("新記録達成！", True, (255, 255, 0))
            screen.blit(
                high_score_text,
                (
                    screen_width // 2 - high_score_text.get_width() // 2,
                    panel_y + 80 * scale_factor,
                ),
            )

        screen.blit(
            score_text,
            (
                screen_width // 2 - score_text.get_width() // 2,
                panel_y + 120 * scale_factor,
            ),
        )
        screen.blit(
            level_text,
            (
                screen_width // 2 - level_text.get_width() // 2,
                panel_y + 160 * scale_factor,
            ),
        )
        screen.blit(
            lines_text,
            (
                screen_width // 2 - lines_text.get_width() // 2,
                panel_y + 200 * scale_factor,
            ),
        )
        screen.blit(
            time_text,
            (
                screen_width // 2 - time_text.get_width() // 2,
                panel_y + 240 * scale_factor,
            ),
        )

        # リトライボタン
        retry_button = Button(
            panel_x + panel_width // 2 - 100 * scale_factor,
            panel_y + 300 * scale_factor,
            200 * scale_factor,
            40 * scale_factor,
            "リトライ",
            action=lambda: "retry",
        )

        menu_button = Button(
            panel_x + panel_width // 2 - 100 * scale_factor,
            panel_y + 350 * scale_factor,
            200 * scale_factor,
            40 * scale_factor,
            "メニューに戻る",
            action=lambda: "menu",
        )

        mouse_pos = pygame.mouse.get_pos()
        retry_button.update(mouse_pos)
        retry_button.draw(screen)

        menu_button.update(mouse_pos)
        menu_button.draw(screen)

        return [retry_button, menu_button]

    def draw_pause_menu(self):
        """ポーズメニューを描画する"""
        # 半透明のオーバーレイ
        overlay = pygame.Surface((screen_width, screen_height), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))  # 半透明の黒
        screen.blit(overlay, (0, 0))

        # ポーズメニューのタイトル
        title_text = title_font.render("ポーズ", True, theme["text"])
        screen.blit(
            title_text,
            (screen_width // 2 - title_text.get_width() // 2, 200 * scale_factor),
        )

        # ボタンの作成
        buttons = []

        # 再開ボタン
        resume_button = Button(
            screen_width // 2 - 150 * scale_factor,
            300 * scale_factor,
            300 * scale_factor,
            50 * scale_factor,
            "ゲームを再開",
            action="resume",
        )

        # テーマ切替ボタン
        theme_button = Button(
            screen_width // 2 - 150 * scale_factor,
            370 * scale_factor,
            300 * scale_factor,
            50 * scale_factor,
            f"テーマ: {current_theme.capitalize()}",
            action="theme",
        )

        # フルスクリーン切替ボタン
        fullscreen_button = Button(
            screen_width // 2 - 150 * scale_factor,
            440 * scale_factor,
            300 * scale_factor,
            50 * scale_factor,
            "フルスクリーン切替",
            action="fullscreen",
        )

        # メニューに戻るボタン
        quit_button = Button(
            screen_width // 2 - 150 * scale_factor,
            510 * scale_factor,
            300 * scale_factor,
            50 * scale_factor,
            "メニューに戻る",
            action="quit",
        )

        buttons = [resume_button, theme_button, fullscreen_button, quit_button]

        # マウス位置の取得と更新
        mouse_pos = pygame.mouse.get_pos()
        for button in buttons:
            button.update(mouse_pos)
            button.draw(screen)

        return buttons

    def check_high_score(self):
        """ハイスコアをチェックして保存する"""
        high_scores = load_high_scores()
        mode_scores = high_scores.get(self.game_mode, [])

        # スプリントモードでゲームオーバー時（クリアしていない場合）はハイスコアに登録しない
        if self.game_mode == "sprint" and not self.game_clear:
            return False

        # 新しいスコアエントリを作成
        new_score = {
            "score": self.score,
            "level": self.level,
            "lines": self.lines_cleared,
            "date": datetime.now().strftime("%Y-%m-%d"),
            "id": str(uuid.uuid4())[:8],  # ユニークID
        }

        # スプリントモードの場合は時間を記録
        if self.game_mode == "sprint":
            new_score["time"] = self.time_played

        # 既存のスコアと重複しないようにする
        # 同じ日付・スコア・レベルの組み合わせがあれば追加しない
        is_duplicate = False
        for score in mode_scores:
            if (
                score.get("date") == new_score["date"]
                and score.get("score") == new_score["score"]
                and score.get("level") == new_score["level"]
            ):
                is_duplicate = True
                break

        # 重複していない場合のみ追加
        if not is_duplicate:
            # ハイスコアリストに追加
            mode_scores.append(new_score)

            # スコアでソート
            if self.game_mode == "sprint":
                # スプリントモードは時間が短い順
                mode_scores.sort(key=lambda x: x.get("time", float("inf")))
            else:
                # その他のモードはスコアが高い順
                mode_scores.sort(key=lambda x: x.get("score", 0), reverse=True)

            # 上位10件のみ保持
            high_scores[self.game_mode] = mode_scores[:10]

            # ハイスコアを保存
            save_high_scores(high_scores)

        # 新しいスコアがトップ5に入っているかチェック
        is_high_score = False
        for i, score in enumerate(mode_scores[:5]):
            if score["id"] == new_score["id"]:
                is_high_score = True
                break

        return is_high_score


# ウィンドウタイトル設定
pygame.display.set_caption("テトリス")

# フォントの初期化
    init_fonts()

# テーマの設定
current_theme = settings.get("theme", "classic")
theme = THEMES[current_theme]

# サウンドの初期化
has_music = False

try:
    # 効果音の読み込み
    click_sound = pygame.mixer.Sound("assets/click.wav")
    move_sound = pygame.mixer.Sound("assets/move.wav")
    rotate_sound = pygame.mixer.Sound("assets/rotate.wav")
    drop_sound = pygame.mixer.Sound("assets/drop.wav")
    clear_sound = pygame.mixer.Sound("assets/clear.wav")
    tetris_sound = pygame.mixer.Sound("assets/tetris.wav")
    level_up_sound = pygame.mixer.Sound("assets/level_up.wav")
    game_over_sound = pygame.mixer.Sound("assets/game_over.wav")
    hold_sound = pygame.mixer.Sound("assets/hold.wav")

    # 音量設定
    click_sound.set_volume(0.3)
    move_sound.set_volume(0.3)
    rotate_sound.set_volume(0.4)
    drop_sound.set_volume(0.5)
    clear_sound.set_volume(0.6)
    tetris_sound.set_volume(0.7)
    level_up_sound.set_volume(0.7)
    game_over_sound.set_volume(0.7)
    hold_sound.set_volume(0.4)

    # BGMの読み込み
    pygame.mixer.music.load("assets/tetris_theme.mp3")
    pygame.mixer.music.set_volume(0.5)
    has_music = True
    except Exception as e:
    print(f"音声ファイルの読み込みエラー: {e}")

    # 音声ファイルがない場合のダミーオブジェクト
    class DummySound:
        def play(self):
            pass

        def set_volume(self, vol):
            pass

    click_sound = DummySound()
    move_sound = DummySound()
    rotate_sound = DummySound()
    drop_sound = DummySound()
    clear_sound = DummySound()
    tetris_sound = DummySound()
    level_up_sound = DummySound()
    game_over_sound = DummySound()
    hold_sound = DummySound()


# スタートメニューの描画
def draw_start_menu():
    # 背景
    screen.fill(theme["background"])

    # タイトル
    title_text = title_font.render("テトリス", True, theme["text"])
    screen.blit(
        title_text,
        (screen_width // 2 - title_text.get_width() // 2, 100 * scale_factor),
    )

    # ボタンの作成
    buttons = []

    # スタートボタン
    start_button = Button(
        screen_width // 2 - 150 * scale_factor,
        250 * scale_factor,
        300 * scale_factor,
        50 * scale_factor,
        "ゲームスタート",
        action="start",
    )

    # ゲームモード切替ボタン
    mode_button = Button(
        screen_width // 2 - 150 * scale_factor,
        320 * scale_factor,
        300 * scale_factor,
        50 * scale_factor,
        f"モード: {settings.get('game_mode', 'marathon').capitalize()}",
        action="game_mode",
    )

    # テーマ切替ボタン
    theme_button = Button(
        screen_width // 2 - 150 * scale_factor,
        390 * scale_factor,
        300 * scale_factor,
        50 * scale_factor,
        f"テーマ: {current_theme.capitalize()}",
        action="theme",
    )

    # エフェクト切替ボタン
    effects_status = "ON" if settings.get("effects", True) else "OFF"
    effects_button = Button(
        screen_width // 2 - 150 * scale_factor,
        460 * scale_factor,
        300 * scale_factor,
        50 * scale_factor,
        f"エフェクト: {effects_status}",
        action="effects",
    )

    # フルスクリーン切替ボタン
    fullscreen_button = Button(
        screen_width // 2 - 150 * scale_factor,
        530 * scale_factor,
        300 * scale_factor,
        50 * scale_factor,
        "フルスクリーン切替",
        action="fullscreen",
    )

    # ハイスコアボタン
    high_scores_button = Button(
        screen_width // 2 - 150 * scale_factor,
        600 * scale_factor,
        300 * scale_factor,
        50 * scale_factor,
        "ハイスコア",
        action="high_scores",
    )

    # 終了ボタン
    quit_button = Button(
        screen_width // 2 - 150 * scale_factor,
        670 * scale_factor,
        300 * scale_factor,
        50 * scale_factor,
        "終了",
        action="quit",
    )

    buttons = [
        start_button,
        mode_button,
        theme_button,
        effects_button,
        fullscreen_button,
        high_scores_button,
        quit_button,
    ]

    # マウス位置の取得と更新
    mouse_pos = pygame.mouse.get_pos()
    for button in buttons:
        button.update(mouse_pos)
        button.draw(screen)

    return buttons


# ハイスコア画面の描画
def draw_high_scores(game):
    # 背景
    screen.fill(theme["background"])

    # タイトル
    title_text = title_font.render("ハイスコア", True, theme["text"])
    screen.blit(
        title_text,
        (screen_width // 2 - title_text.get_width() // 2, 50 * scale_factor),
    )

    # モード選択ボタン
    mode_buttons = []
    modes = ["marathon", "sprint", "ultra"]
    mode_names = {"marathon": "マラソン", "sprint": "スプリント", "ultra": "ウルトラ"}

    for i, mode in enumerate(modes):
        button = Button(
            screen_width // 2 - 300 * scale_factor + i * 200 * scale_factor,
            120 * scale_factor,
            180 * scale_factor,
            40 * scale_factor,
            mode_names[mode],
            action=mode,
        )

        # 選択中のモードを強調
        if mode == game.game_mode:
            button.bg_color = theme["button_hover"]

        mouse_pos = pygame.mouse.get_pos()
        button.update(mouse_pos)
        button.draw(screen)
        mode_buttons.append(button)

    # ハイスコアの表示
    high_scores = load_high_scores().get(game.game_mode, [])

    if not high_scores:
        no_scores_text = font.render("記録はありません", True, theme["text"])
        screen.blit(
            no_scores_text,
            (
                screen_width // 2 - no_scores_text.get_width() // 2,
                250 * scale_factor,
            ),
        )
    else:
        # ヘッダー
        if game.game_mode == "marathon":
            headers = ["順位", "スコア", "レベル", "ライン", "日付"]
        elif game.game_mode == "sprint":
            headers = ["順位", "タイム", "日付"]
        else:  # ultra
            headers = ["順位", "スコア", "ライン", "日付"]

        for i, header in enumerate(headers):
            header_text = font.render(header, True, theme["text"])
            screen.blit(
                header_text,
                (
                    screen_width // 2 - 300 * scale_factor + i * 150 * scale_factor,
                    180 * scale_factor,
                ),
            )

        # スコア一覧
        for i, score in enumerate(high_scores[:10]):  # 上位10件まで表示
            y_pos = 220 * scale_factor + i * 30 * scale_factor

            # 順位
            rank_text = font.render(f"{i+1}", True, theme["text"])
            screen.blit(
                rank_text,
                (screen_width // 2 - 300 * scale_factor, y_pos),
            )

            if game.game_mode == "marathon":
                # スコア
            score_text = font.render(f"{score['score']}", True, theme["text"])
                screen.blit(
                    score_text,
                    (screen_width // 2 - 150 * scale_factor, y_pos),
                )

                # レベル
            level_text = font.render(f"{score['level']}", True, theme["text"])
                screen.blit(
                    level_text,
                    (screen_width // 2, y_pos),
                )

                # ライン
                lines_text = font.render(f"{score['lines']}", True, theme["text"])
                screen.blit(
                    lines_text,
                    (screen_width // 2 + 150 * scale_factor, y_pos),
                )

                # 日付
                date_text = font.render(score.get("date", "不明"), True, theme["text"])
                screen.blit(
                    date_text,
                    (screen_width // 2 + 300 * scale_factor, y_pos),
                )

            elif game.game_mode == "sprint":
                # タイム
                if "time" in score:
                    # 浮動小数点数を整数に変換
                    minutes = int(score["time"]) // 60
                    seconds = int(score["time"]) % 60
                    time_text = font.render(
                        f"{minutes}:{seconds:02d}",
                        True,
                        theme["text"],
                )
    else:
                    time_text = font.render("--:--", True, theme["text"])

        screen.blit(
                    time_text,
                    (screen_width // 2 - 150 * scale_factor, y_pos),
                )

                # 日付
                date_text = font.render(score.get("date", "不明"), True, theme["text"])
                screen.blit(
                    date_text,
                    (screen_width // 2, y_pos),
                )

            else:  # ultra
                # スコア
                score_text = font.render(f"{score['score']}", True, theme["text"])
                screen.blit(
                    score_text,
                    (screen_width // 2 - 150 * scale_factor, y_pos),
                )

                # ライン
                lines_text = font.render(f"{score['lines']}", True, theme["text"])
                screen.blit(
                    lines_text,
                    (screen_width // 2, y_pos),
                )

                # 日付
                date_text = font.render(score.get("date", "不明"), True, theme["text"])
                screen.blit(
                    date_text,
                    (screen_width // 2 + 150 * scale_factor, y_pos),
        )

    # 戻るボタン
    back_button = Button(
        screen_width // 2 - 100 * scale_factor,
        screen_height - 100 * scale_factor,
        200 * scale_factor,
        40 * scale_factor,
        "戻る",
        action="back",
    )

    mouse_pos = pygame.mouse.get_pos()
    back_button.update(mouse_pos)
    back_button.draw(screen)

    return mode_buttons + [back_button]


# メイン関数
def main():
    # スクリーンの初期化
    global screen
    screen = initialize_screen(fullscreen=settings.get("fullscreen", False))

    # ゲーム状態
    game_state = "menu"
    game = Tetris()
    menu_buttons = []
    high_score_buttons = []
    game_over_button = None
    pause_buttons = None

    # ゲームループの設定
    clock = pygame.time.Clock()
    running = True

    # ゲーム起動時にBGMを再生
    if has_music and settings.get("music", True) and game_state == "playing":
        pygame.mixer.music.play(-1)  # -1で無限ループ

    while running:
        now = pygame.time.get_ticks()
        dt = clock.get_time() / 1000.0  # 前フレームからの経過時間（秒）

        # イベント処理
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    if game_state == "playing":
                        if game.paused:
                            game.toggle_pause()
                        else:
                            game_state = "menu"
                            if has_music:
                                pygame.mixer.music.stop()
                    else:
                        running = False

                elif event.key == pygame.K_f:
                    toggle_fullscreen()

                elif game_state == "playing" and not game.paused and not game.game_over:
                    if event.key == pygame.K_LEFT:
                        game.move(-1)
                        game.das_timer = 0  # DASタイマーをリセット
                    elif event.key == pygame.K_RIGHT:
                        game.move(1)
                        game.das_timer = 0  # DASタイマーをリセット
                    elif event.key == pygame.K_UP:
                        game.rotate(clockwise=True)  # 時計回り回転
                    elif event.key == pygame.K_z:
                        game.rotate(clockwise=False)  # 反時計回り回転
                    elif event.key == pygame.K_DOWN:
                        game.soft_drop = True
                    elif event.key == pygame.K_SPACE:
                        game.drop()
                    elif event.key == pygame.K_c:
                        game.hold_piece()
                    elif event.key == pygame.K_p:
                        game.toggle_pause()
                elif event.key == pygame.K_r and game.game_over:
                    game = Tetris(game_mode=game.game_mode)

            elif event.type == pygame.KEYUP and game_state == "playing":
                if event.key == pygame.K_DOWN:
                    game.soft_drop = False

            elif event.type == pygame.MOUSEBUTTONDOWN:
                if game_state == "menu":
                    for button in menu_buttons:
                        result = button.handle_event(event)
                        if result == "start":
                            game = Tetris(
                                game_mode=settings.get("game_mode", "marathon")
                            )
                            game_state = "playing"

                            # BGM再生
                            if has_music and settings.get("music", True):
                                pygame.mixer.music.play(-1)
                        elif result == "theme":
                            cycle_theme()
                        elif result == "game_mode":
                            # ゲームモードを切り替える
                            current_mode = settings.get("game_mode", "marathon")
                            if current_mode == "marathon":
                                settings["game_mode"] = "sprint"
                            elif current_mode == "sprint":
                                settings["game_mode"] = "ultra"
                            else:
                                settings["game_mode"] = "marathon"
                            save_settings(settings)
                            # ボタンのテキストを更新
                            for btn in menu_buttons:
                                if "モード" in btn.text:
                                    btn.text = f"モード: {settings.get('game_mode', 'marathon').capitalize()}"
                        elif result == "effects":
                            # エフェクト設定の切り替え
                            settings["effects"] = not settings.get("effects", True)
                            save_settings(settings)
                            # ボタンのテキストを更新
                            for btn in menu_buttons:
                                if btn.action == "effects":
                                    effects_status = (
                                        "ON" if settings.get("effects", True) else "OFF"
                                    )
                                    btn.text = f"エフェクト: {effects_status}"
                        elif result == "fullscreen":
                            toggle_fullscreen()
                        elif result == "high_scores":
                            game_state = "high_scores"
                        elif result == "quit":
                            running = False

                elif game_state == "high_scores":
                    for button in high_score_buttons:
                        result = button.handle_event(event)
                        if result == "back":
                            game_state = "menu"
                        elif result in ["marathon", "sprint", "ultra"]:
                            game.game_mode = result

                elif game_state == "playing":
                    # ゲームオーバー画面のボタン
                    if game.game_over and game_over_button:
                        for button in game_over_button:
                            result = button.handle_event(event)
                            if result == "retry":
                                game = Tetris(game_mode=game.game_mode)
                            elif result == "menu":
                                game_state = "menu"
                                if has_music:
                                    pygame.mixer.music.stop()

                    # ゲームクリア画面のボタン
                    if game.game_clear and game_over_button:
                        for button in game_over_button:
                            result = button.handle_event(event)
                            if result == "retry":
                                game = Tetris(game_mode=game.game_mode)
                            elif result == "menu":
                                game_state = "menu"
                                if has_music:
                                    pygame.mixer.music.stop()

                    # ポーズメニューのボタン
                    if game.paused and pause_buttons:
                        for button in pause_buttons:
                            result = button.handle_event(event)
                            if result == "resume":
                                game.toggle_pause()
                            elif result == "theme":
                                cycle_theme()
                            elif result == "fullscreen":
                                toggle_fullscreen()
                            elif result == "quit":
                                game_state = "menu"
                                if has_music:
                                    pygame.mixer.music.stop()

        # 状態に応じた更新と描画
        if game_state == "menu":
            # メニューボタンを毎フレーム更新
            menu_buttons = draw_start_menu()

        elif game_state == "high_scores":
            high_score_buttons = draw_high_scores(game)

        elif game_state == "playing":
            # ゲーム状態の更新
            game.update(dt)

            # ゲーム描画
            game_over_button = game.draw()

            # ポーズメニュー
            pause_buttons = None
            if game.paused:
                pause_buttons = game.draw_pause_menu()

        # 画面の更新
        pygame.display.flip()

        # フレームレート制限
        clock.tick(60)

    pygame.quit()


if __name__ == "__main__":
    main()

    main()
